package main

import (
	"context"
	"fmt"
	"log"
	"net"
	"path/filepath"

	"google.golang.org/grpc"

	// Adjust the import path based on your module path
	plsv1 "github.com/Networks-it-uc3m/l2sm-switch/api/v1"

	"github.com/Networks-it-uc3m/l2sm-switch/internal/inits"
	"github.com/Networks-it-uc3m/l2sm-switch/pkg/nedpb"
	"github.com/Networks-it-uc3m/l2sm-switch/pkg/ovs"
)

// server is used to implement nedpb.VxlanServiceServer
type server struct {
	nedpb.UnimplementedNedServiceServer
	Settings plsv1.Settings
}

func main() {

	configDir := filepath.Join(plsv1.DEFAULT_CONFIG_PATH, plsv1.SETTINGS_FILE)
	neighborsDir := filepath.Join(plsv1.DEFAULT_CONFIG_PATH, plsv1.NEIGHBOR_FILE)

	var settings plsv1.Settings
	err := inits.ReadFile(configDir, &settings)

	if err != nil {
		fmt.Println("Error with the provided file. Error:", err)
		return
	}

	fmt.Println("Initializing switch, connected to controller: ", settings.ControllerIP)

	_, err = inits.ConfigureSwitch(settings.NodeName, settings.SwitchName, settings.ControllerPort, settings.ControllerIP)
	if err != nil {
		log.Fatalf("error initializing ned: %v", err)
	}

	var node plsv1.Node
	err = inits.ReadFile(neighborsDir, &node)

	if err != nil {
		fmt.Println("Error with the provided file. Error:", err)
		return
	}

	err = inits.ConnectToNeighbors(settings.SwitchName, node)
	if err != nil {
		fmt.Println("Could not connect neighbors: ", err)
		return
	}

	// Listen on a TCP port
	lis, err := net.Listen("tcp", ":50051") // Choose your port
	if err != nil {
		log.Fatalf("failed to listen: %v", err)
	}

	// Create a gRPC server
	grpcServer := grpc.NewServer()

	// Register the server
	nedpb.RegisterNedServiceServer(grpcServer, &server{Settings: settings})

	log.Printf("gRPC server listening on :50051")
	if err := grpcServer.Serve(lis); err != nil {
		log.Fatalf("failed to serve: %v", err)
	}
}

// CreateVxlan implements nedpb.VxlanServiceServer
func (s *server) CreateVxlan(ctx context.Context, req *nedpb.CreateVxlanRequest) (*nedpb.CreateVxlanResponse, error) {
	ipAddress := req.GetIpAddress()

	// Implement your logic to create a VxLAN with the given IP address
	// For example, call a function from pkg/ovs/vsctl.go
	// success, message := ovs.CreateVxlan(ipAddress)
	//TODO: finish. its required to disclose what happens if i dont know the number of vxlans --- vxlan name generated by ovs pkg?
	// Placeholder implementation
	ovs.UpdateVirtualSwitch(ovs.WithName(s.Settings.SwitchName), ovs.WithVxlans([]plsv1.Vxlan{{VxlanId: "", LocalIp: "", RemoteIp: ipAddress, UdpPort: ""}}))
	message := fmt.Sprintf("VxLAN with IP %s created successfully", ipAddress)

	return &nedpb.CreateVxlanResponse{
		Success: true,
		Message: message,
	}, nil
}

// AttachInterface implements nedpb.VxlanServiceServer
func (s *server) AttachInterface(ctx context.Context, req *nedpb.AttachInterfaceRequest) (*nedpb.AttachInterfaceResponse, error) {
	interfaceName := req.GetInterfaceName()

	// Create a new interface and attach it to the bridge
	newPort, err := ovs.AddInterfaceToBridge(interfaceName)
	if err != nil {
		return nil, fmt.Errorf("failed to create interface: %v", err)
	}

	vs, err := ovs.UpdateVirtualSwitch(ovs.WithName(s.Settings.SwitchName), ovs.WithPorts([]plsv1.Port{{Name: newPort}}))

	if err != nil {
		return nil, fmt.Errorf("failed to add interface to bridge: %v", err)
	}

	interfaceNum, err := vs.GetPortNumber(newPort)
	if err != nil {
		return nil, fmt.Errorf("failed to get port number: %v", err)
	}

	nodeName := s.Settings.NodeName
	if nodeName == "" {
		nodeName = "default-node" // Fallback if NODE_NAME is not set
	}

	return &nedpb.AttachInterfaceResponse{
		InterfaceNum: interfaceNum,
		NodeName:     nodeName,
	}, nil
}
